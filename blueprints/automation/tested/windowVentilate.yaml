blueprint:
  name: Lüften-Erinnerung – Fenster-Gruppe (multi Empfänger, nur wenn zuhause)
  description: >
    Erinnert ans Lüften, wenn in einer Fenster-Zone seit X Stunden nicht gelüftet wurde.
    Nutzt eine Fenster-GRUPPE oder einen einzelnen Fensterkontakt (binary_sensor.*)
    und speichert den Zeitpunkt der letzten ausreichenden Lüftung in einem input_datetime.
    Benachrichtigt NUR die Empfänger, deren Präsenz „zuhause“ ist (pro Empfänger: Präsenz-Entity + Notify-Service).
    Prüfintervall und Stunden bis Erinnerung sind einstellbar.
  domain: automation

  input:
    window_group:
      name: Fenster-Gruppe oder einzelner Fensterkontakt (binary_sensor.*)
      selector: { entity: { domain: binary_sensor } }

    last_ventilated:
      name: input_datetime – Zeitpunkt letzte ausreichende Lüftung
      selector: { entity: { domain: input_datetime } }

    min_open_minutes:
      name: Mindestdauer „Fenster offen“ (Min.), um als gelüftet zu zählen
      default: 5
      selector: { number: { min: 1, max: 60, step: 1, unit_of_measurement: "min" } }

    remind_after_hours:
      name: Erinnern nach so vielen Stunden ohne Lüften
      description: Ab dieser Zeitspanne ohne Lüften startet die Erinnerungsschleife.
      default: 6
      selector: { number: { min: 1, max: 48, step: 1, unit_of_measurement: "h" } }

    check_every_minutes:
      name: Prüf-/Erinnerungsintervall (Minuten)
      description: Wie oft soll geprüft werden (und ggf. erneut erinnert)?
      default: 30
      selector: { number: { min: 5, max: 120, step: 5, unit_of_measurement: "min" } }

    active_start:
      name: Aktive Zeit – Start
      default: "08:00:00"
      selector: { time: {} }

    active_end:
      name: Aktive Zeit – Ende
      default: "21:00:00"
      selector: { time: {} }

    # Bis zu 5 Empfänger: pro Empfänger Präsenz-Entity + notify-Service
    recipient_1_presence:
      name: Empfänger 1 – Präsenz (person/device_tracker/group/binary_sensor)
      default: ""
      selector: { entity: {} }
    recipient_1_notify:
      name: Empfänger 1 – Notify-Service (z. B. notify.mobile_app_iphone)
      default: ""
      selector: { text: {} }

    recipient_2_presence:
      name: Empfänger 2 – Präsenz
      default: ""
      selector: { entity: {} }
    recipient_2_notify:
      name: Empfänger 2 – Notify-Service
      default: ""
      selector: { text: {} }

    recipient_3_presence:
      name: Empfänger 3 – Präsenz
      default: ""
      selector: { entity: {} }
    recipient_3_notify:
      name: Empfänger 3 – Notify-Service
      default: ""
      selector: { text: {} }

    recipient_4_presence:
      name: Empfänger 4 – Präsenz
      default: ""
      selector: { entity: {} }
    recipient_4_notify:
      name: Empfänger 4 – Notify-Service
      default: ""
      selector: { text: {} }

    recipient_5_presence:
      name: Empfänger 5 – Präsenz
      default: ""
      selector: { entity: {} }
    recipient_5_notify:
      name: Empfänger 5 – Notify-Service
      default: ""
      selector: { text: {} }

mode: restart
max_exceeded: silent

variables:
  _grp: !input window_group
  _dt:  !input last_ventilated
  _min_open: !input min_open_minutes
  _after_h:  !input remind_after_hours
  _interval: !input check_every_minutes
  _start: !input active_start
  _end:   !input active_end

  # Empfänger-Liste bauen (nur ausgefüllte Paare)
  _r1p: !input recipient_1_presence
  _r1s: !input recipient_1_notify
  _r2p: !input recipient_2_presence
  _r2s: !input recipient_2_notify
  _r3p: !input recipient_3_presence
  _r3s: !input recipient_3_notify
  _r4p: !input recipient_4_presence
  _r4s: !input recipient_4_notify
  _r5p: !input recipient_5_presence
  _r5s: !input recipient_5_notify

  _recipients: >
    {% set lst = [] %}
    {% for p,s in [(_r1p,_r1s),(_r2p,_r2s),(_r3p,_r3s),(_r4p,_r4s),(_r5p,_r5s)] %}
      {% if (p | string) | length > 0 and (s | string) | length > 0 %}
        {% set _ = lst.append({'presence': p, 'service': s}) %}
      {% endif %}
    {% endfor %}
    {{ lst }}

trigger:
  # 1) „Als gelüftet zählen“: sobald Gruppe/Sensor so lange offen war
  - platform: state
    entity_id: !input window_group
    to: "on"
    for:
      minutes: !input min_open_minutes
    id: opened_long_enough

  # 2) Erinnerungs-Takt: jede Minute → wir filtern später per Modulo
  - platform: time_pattern
    minutes: "/1"
    id: periodic_check

condition: []

action:
  - choose:

      # ===== CASE 1: Zeitpunkt „gelüftet“ speichern =====
      - conditions: "{{ trigger.id == 'opened_long_enough' }}"
        sequence:
          - service: input_datetime.set_datetime
            target: { entity_id: "{{ _dt }}" }
            data:
              datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
          - stop: "Gelüftet-Zeitpunkt gespeichert."

      # ===== CASE 2: Erinnerung prüfen/senden (nur im gewählten Intervall) =====
      - conditions: "{{ trigger.id == 'periodic_check' }}"
        sequence:
          # 2.0: Nur ausführen, wenn diese Minute zum Intervall passt
          - condition: template
            value_template: "{{ (now().minute % (_interval | int)) == 0 }}"

          # 2.1: aktives Zeitfenster? (Hinweis: deckt Start < Ende ab)
          - condition: template
            value_template: >
              {% set nowt = now().strftime('%H:%M:%S') %}
              {{ _start <= nowt <= _end }}

          # 2.2: Nicht erinnern, wenn gerade ein Fenster offen ist
          - condition: state
            entity_id: !input window_group
            state: "off"

          # 2.3: Stunden seit letzter Lüftung
          - variables:
              last_str: "{{ states(_dt) }}"
              hours_since: >
                {% if last_str in ['unknown','unavailable','none',''] %}
                  999
                {% else %}
                  {{ ((now() - as_datetime(last_str)).total_seconds()/3600) | float(999) | round(1) }}
                {% endif %}

          # 2.4: Mindestzeit überschritten?
          - condition: template
            value_template: "{{ hours_since >= _after_h }}"

          # 2.5: Titel/Message vorbereiten
          - variables:
              _title: "Bitte lüften – {{ state_attr(_grp, 'friendly_name') or 'Fensterzone' }}"
              _msg: "Seit {{ hours_since }} h nicht gelüftet. Bitte ein Fenster mindestens {{ _min_open }} Minuten öffnen."

          # 2.6: Dynamisch an alle 'zuhause'-Empfänger senden
          - repeat:
              for_each: "{{ _recipients }}"
              sequence:
                - variables:
                    _entity: "{{ repeat.item.presence }}"
                    _svc:    "{{ repeat.item.service }}"
                    _state:  "{{ states(_entity) if _entity in states else 'unknown' }}"
                    _domain: "{{ states[_entity].domain if _entity in states else '' }}"
                    _ishome: >
                      {% if _domain in ['person','device_tracker','group'] %}
                        {{ _state in ['home','on'] }}
                      {% elif _domain == 'binary_sensor' %}
                        {{ _state == 'on' }}
                      {% else %}
                        {{ _state in ['home','on'] }}
                      {% endif %}
                - if:
                    - condition: template
                      value_template: "{{ _ishome }}"
                  then:
                    - service: "{{ _svc }}"
                      data:
                        title: "{{ _title }}"
                        message: "{{ _msg }}"

          # 2.7: Zusätzlich im UI anzeigen (kannst du bei Bedarf entfernen)
          - service: persistent_notification.create
            data:
              title: "{{ _title }}"
              message: "{{ _msg }}"